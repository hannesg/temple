module Temple
  module Filters
    # Embeds multiple engines
    class EmbeddedEngine < Filter
    
      class Registerer
      
	attr_reader :engines

        def initialize(hash, engines)
          @hash = hash
	  @engines = engines
        end
        
        def register(name, engine)
          @hash[name.to_s] = engine
        end

	def allow(name)
	  @hash[name.to_s] = @engines[name.to_s]
	end

        def deny(name)
	  @hash[name.to_s] = nil
	end

	def engine(name)
	  engines[name.to_s]
	end

	def wrap(name, engine)
	  engine.inner = self.engine(name)
	  register(name, engine)
	end
      
      end
   
	class Extractor

	  attr_reader :statics, :newlines, :expressions

		def initialize(content)
			@statics = []
			@newlines = []
			@expressions = []
			extract(content)
		end

		def text
			statics.map(&:last).join
		end

		def extract(content)
		  type = content[0]
		  case type
		    when :multi then
		      return [:multi, *content[1..-1].map{|token| extract(token) }]
		    when :static then
                      return @statics << content
		    when :newline then
                      return @newlines << content
                    else
                      placeholder = [:static, '']
                      @expressions << [ content, placeholder ]
                      @statics << placeholder
		      return placeholder
                    end
		  
                end
		
		# TODO:
		# this is bloody, find a better replacement scheme.
		def protecting_expressions
		  found = false
		  @expressions.each_with_index do |(content, placeholder), i|
		    placeholder[1] = "pro#{i}tect"
		    found = true
		  end
		  result = yield text
		  return [:static, result] unless found
		  multi = [:multi]
		  while result.size > 0
		    match = /pro(\d+)tect/.match(result)
		    if match.nil?
			multi << [:static, result]
			return multi
		    end
		    if match.pre_match.size > 0
			multi << [:static, match.pre_match]	
		    end
		    multi << @expressions[match[1].to_i][0]
		    result = match.post_match
		  end
		  return multi
		end

		def force_static!
		  unless @expressions.empty?
			raise "Only :static,:multi and :newline expressions are allowed inside this embedded engine. Found: #{@expressions.map(&:first).inspect}"
		  end
		end
	end
     
      # The base for all used engines.
      # Does nothing but passing thru the original content.
      class Engine
        
        include Temple::Mixins::Options
        
        def call(name, content)
          return content
        end

      end
      
      # An engine which forces pure static input and wraps the content in a :code expression
      class CodeEngine < Engine
      
        def call(name, content)
	  ex = Extractor.new(content)
	  ex.force_static!    
	  return [:code, ex.text]
        end
        
      end
      
      # An engine which uses a tilt engine as backend.
      # This version renders the content at compile time
      # and embeds it as static text.
      class TiltEngine < Engine
      
        def call(name, content)
	  tilt_name = options[:as] || name
          tilt_engine = Tilt[tilt_name]
	  raise "Cannot find a tilt engine named #{tilt_name}." unless tilt_engine
	  tilt_options = options
	  ex = Extractor.new(content)
          return [ :multi, tilt_render(tilt_engine, tilt_options, name, ex), *ex.newlines ]
        end

	protected
	def tilt_render(tilt_engine, tilt_options, name, extractor)
	  extractor.force_static!
          return [:static, tilt_engine.new(tilt_options){ extractor.text }.render ]
        end

      end
      
      # An engine which extracts the ruby source
      # generated by Tilt. This way the ruby source is
      # directly embedded into the resulting source,
      # which leads to nice performance.
      # 
      # This however only works for static content and
      # compiling tilt engines.
      class PrecompiledTiltEngine < TiltEngine
        
	protected
        def tilt_render(tilt_engine, tilt_options, name, extractor)
           extractor.force_static!
	   return [:dynamic, tilt_engine(tilt_options).new{ extractor.text }.send(:precompiled, {}).first]
        end
        
      end
    
      # A special tilt engine which tries to recover
      # expressions from the original input. This doesn't
      # work everywhere and under all conditions, but allows
      # interpolations and similiar things in embedded 
      # markup languages.
      #
      # @example
      #   en = ProtectingTiltEngine.new
      #   en.call('markdown',[:multi,[:dynamic, 'lala']]) #=> 
      class ProtectingTiltEngine < TiltEngine
	
	protected
	def tilt_render(tilt_engine, tilt_options, name, extractor)
	  return extractor.protecting_expressions do |text|
	     tilt_engine.new(tilt_options){ text }.render
	  end
	end
     
      end
 
      # An engine which wraps another engine.
      # This is mainly used to surround output with html tags
      # or add interpolation.
      #
      # Concrete implementations should overwrite {#preprocess}
      # and/or {#postprocess}.
      #
      # @abstract
      class WrapEngine < Engine
     
	# gets the wrapped engine 
        def inner
	  @inner ||= (@options[:engine] || Engine.new) 
	end

        # sets the wrapped engine
        def inner=( engine )
          raise "The inner engine should not be setted twice" if @inner
	  @inner = engine
        end
      
        def call(name, content)
          return postprocess( name, inner.call( name, preprocess(name, content) ) )
        end
        
      protected
        def preprocess(name, content)
          return content
        end
        
        def postprocess(name, content)
          return content
        end
      
      end

      # Wraps the output of another engine into
      # an html-tag.
      class WrapTagEngine < WrapEngine

	def initialize(*_)
          super
	  unless options[:tag]
		raise ArgumentError, "#{self.class} doesn't know which tag to use. Please supply a :tag option."
	  end
	end

      protected
        def postprocess(name, content)
	  return [
		:html,
		:tag,
		options[:tag],
		( options[:attributes].kind_of?(Hash) ? 
			[:html, :attrs, *options[:attributes].map{|k,v| [:html, :attr, k.to_s, [:static, v.to_s]]}] :
			[:html, :attrs]
		),
		content]	
	end

      end
     
      class TempleEngine < Engine

	

      end

      def initialize(options = {}, *rest, &block)
        engines = options.key?(:engines) ? options[:engines].clone : {}
        if block_given?
          Registerer.new(engines,self.class.default_options[:engines]).instance_eval(&block)
        end
        options[:engines] = ImmutableHash.new(engines.freeze,(options[:use_global_engines] == false) ? {} : self.class.default_options[:engines])
        super(options, *rest)
      end
      
      self.default_options[:engines] = MutableHash.new
      
      # Registers an engine globally under a certain name.
      # 
      # @example
      #   Temple::Filter::EmbeddedEngine.register(:foo, Temple::Filter::EmbeddedEngine::Engine.new )
      def self.register(name, engine)
        engines[name.to_s] = engine
      end

      def self.engine(name)
	engines[name.to_s]
      end

      def self.engines
	self.default_options[:engines]
      end
      
      def on_embedded_engine(name, content)
        name = name.to_s
        # search the engine in the options
        engine = options[:engines][name]
        if engine
          return engine.call(name, content)
        else
          raise ArgumentError, "Embedded engine #{name} not found"
        end
      end
 
    
      # css and javascript code is simply surrounded with tags
      register :javascript, WrapTagEngine.new( :tag => 'script', :attributes => {'type' => 'text/javascript'})
      register :style, WrapTagEngine.new( :tag => 'style', :attributes => {'type' => 'text/css' })
      
      # ruby code is embedded
      register :ruby, CodeEngine.new

    end
    
    
  end
end
