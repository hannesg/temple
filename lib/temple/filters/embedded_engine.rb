module Temple
  module Filters
    # Embeds multiple engines
    class EmbeddedEngine < Filter
    
      class Registerer
      
        attr_reader :engines

        def initialize(hash, engines)
          @hash = hash
          @engines = engines
        end
          
        def register(name, engine)
          @hash[name.to_s] = engine
        end

        def allow(name)
          @hash[name.to_s] = @engines[name.to_s]
        end

        def deny(name)
          @hash[name.to_s] = nil
        end

        def engine(name)
          engines[name.to_s]
        end

        def wrap(name, engine)
          engine.inner = self.engine(name)
          register(name, engine)
        end

      end
    
      # The base for all used engines.
      # Does nothing but passing thru the original content.
      class Engine

        include Temple::Mixins::Options

        def call(name, content)
          return content
        end

      end

      # An engine which forces pure static input and wraps the content in a :code expression
      class CodeEngine < Engine

        def call(name, content)
          ex = OnlyStatic::Enforce.new
          ex.call(*content)
          return [:code, ex.text]
        end

      end

      # An engine which uses a tilt engine as backend.
      # This version renders the content at compile time
      # and embeds it as static text.
      class TiltEngine < Engine

        def call(name, content)
          tilt_name = options[:as] || name
          tilt_engine = Tilt[tilt_name]
          raise "Cannot find a tilt engine named #{tilt_name}." unless tilt_engine
          tilt_options = options
          ex = OnlyStatic::IgnoreDynamic.new
          ex.call(*content)
          return [ :multi, tilt_render(tilt_engine, tilt_options, name, content), *ex.newlines ]
        end

      protected
        def tilt_render(tilt_engine, tilt_options, name, content)
          ex = OnlyStatic::Enforce.new
          ex.call(*content)
          return [:static, tilt_engine.new(tilt_options){ ex.text }.render ]
        end

      end

      # An engine which extracts the ruby source
      # generated by Tilt. This way the ruby source is
      # directly embedded into the resulting source,
      # which leads to nice performance.
      # 
      # This however only works for static content and
      # compiling tilt engines.
      class PrecompiledTiltEngine < TiltEngine

      protected

        def tilt_render(tilt_engine, tilt_options, name, content)
          ex = OnlyStatic::Enforce.new
          ex.call(*content)
          return [:dynamic, tilt_engine(tilt_options).new{ ex.text }.send(:precompiled, {}).first]
        end

      end

      # A special tilt engine which tries to recover
      # expressions from the original input. This doesn't
      # work everywhere and under all conditions, but allows
      # interpolations and similiar things in embedded 
      # markup languages.
      #
      # @example
      #   en = ProtectingTiltEngine.new
      #   en.call('markdown',[:multi,[:dynamic, 'lala']]) #=> 
      class ProtectingTiltEngine < TiltEngine

      protected
        def tilt_render(tilt_engine, tilt_options, name, content)
          ex = OnlyStatic::MaskDynamic.new
          ex.call(*content)
          return ex.protecting_expressions do |text|
             tilt_engine.new(tilt_options.to_hash){ text }.render
          end
        end
      end

      # An engine which wraps another engine.
      # This is mainly used to surround output with html tags
      # or add interpolation.
      #
      # Concrete implementations should overwrite {#preprocess}
      # and/or {#postprocess}.
      #
      # @abstract
      class WrapEngine < Engine

        # gets the wrapped engine 
        def inner
          @inner ||= (@options[:engine] || Engine.new) 
        end

        # sets the wrapped engine
        def inner=( engine )
          raise "The inner engine should not be setted twice" if @inner
          @inner = engine
        end

        def call(name, content)
          return postprocess( name, inner.call( name, preprocess(name, content) ) )
        end

      protected
        def preprocess(name, content)
          return content
        end

        def postprocess(name, content)
          return content
        end

      end

      # Wraps the output of another engine into
      # an html-tag.
      class WrapTagEngine < WrapEngine

        def initialize(*_)
          super
          unless options[:tag]
            raise ArgumentError, "#{self.class} doesn't know which tag to use. Please supply a :tag option."
          end
        end

      protected
        def postprocess(name, content)
          return [
            :html,
            :tag,
            options[:tag],
            ( options[:attributes].kind_of?(Hash) ? 
                [:html, :attrs, *options[:attributes].map{|k,v| [:html, :attr, k.to_s, [:static, v.to_s]]}] :
                [:html, :attrs]
            ),
            content]
        end

      end

      #TODO: find a way to fetch the last Sexp-tree before the generator for a generic temple-engine
      class TempleEngine < Engine

      end

      def initialize(options = {}, *rest, &block)
        engines = options.key?(:engines) ? options[:engines].clone : {}
        if block_given?
          Registerer.new(engines,self.class.default_options[:engines]).instance_eval(&block)
        end
        options[:engines] = ImmutableHash.new(engines.freeze,(options[:use_global_engines] == false) ? {} : self.class.default_options[:engines])
        super(options, *rest)
      end

      self.default_options[:engines] = MutableHash.new

      # Registers an engine globally under a certain name.
      # 
      # @example
      #   Temple::Filter::EmbeddedEngine.register(:foo, Temple::Filter::EmbeddedEngine::Engine.new )
      def self.register(name, engine)
        engines[name.to_s] = engine
      end

      def self.engine(name)
        engines[name.to_s]
      end

      def self.engines
        self.default_options[:engines]
      end

      def on_embed(name, content)
        name = name.to_s
        # search the engine in the options
        engine = options[:engines][name]
        if engine
          return engine.call(name, content)
        else
          raise ArgumentError, "Embedded engine #{name} not found"
        end
      end
      
      # css and javascript code is simply surrounded with tags
      register :javascript, WrapTagEngine.new( :tag => 'script', :attributes => {'type' => 'text/javascript'})
      register :style, WrapTagEngine.new( :tag => 'style', :attributes => {'type' => 'text/css' })
      
      # ruby code is embedded
      register :ruby, CodeEngine.new

    end
  end
end
